'''
Given an array A of N integers.

Find the largest continuous sequence in a array which sums to zero.



Problem Constraints

1 <= N <= 106

-107 <= A[i] <= 107



Input Format

Single argument which is an integer array A.



Output Format

Return an array denoting the longest continuous sequence with total sum of zero.

NOTE : If there are multiple correct answers, return the sequence which occurs first in the array.



Example Input

    A = [1,2,-2,4,-4]
 '''

class Solution:
    # @param A : list of integers
    # @return a list of integers
    '''
    First create prefix sum and check any element of prefix sum is being repeated, then i+1,j index shall
    give the asnser. also if any pre_sum element is zero , then start index will be zero (prefix sum is sum start fro)
    zero element)
    '''
    def get_pre_sum(self, A):
        '''Calculate prefix sum'''
        sum = 0
        pre_sum = []
        for i in range(len(A)):
            sum += A[i]
            pre_sum.append(sum)
        return pre_sum

    def lszero(self, A):
        pre_sum=self.get_pre_sum(A)
        index_map = {}
        N = len(pre_sum)
        #we will create map of index and pre_sum element with maintaing  start and end and end -s variable
        start = 0
        end = -1
        for i in range(N):
#Any pre_sum element is zero , then start index will be zero (prefix sum is sum start from zero element)
            if pre_sum[i] == 0:
                s = 0
                e = i
                #check if max length of pre_sum= zero is greater than start end index, if yes then update
                #the global variable
                if e-s >= end - start:
                    start = s
                    end = e
            #if any pre_sum non zero element come first time then update map
            elif pre_sum[i] not in index_map:
                index_map[pre_sum[i]] = i
            else:
                s = index_map[pre_sum[i]] + 1
                e = i
                #same as above , update global start and end index if lenth is more
                if e-s > end - start:
                    start = s
                    end = e
                #If 2 length are equal then array which come first shall be anser, so updating smaller s,e
                elif e-s == end - start and s < start:
                    start = s
                    end = e
        return A[start:end+1]

if __name__ == '__main__':
    A = [ 1, 2, -3, 3 ]
    scaler=Solution()
    print(scaler.lszero(A))